import { Context } from "probot";
import { GeneratedReview } from "../review/generator";

export class GitHubCommentsHandler {
  async postReview(
    context: Context<"pull_request.opened" | "pull_request.synchronize">,
    review: GeneratedReview,
    owner: string,
    repo: string,
    pullNumber: number
  ): Promise<void> {
    const body = this.formatReviewComment(review);

    await context.octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: pullNumber,
      body,
    });
  }

  private formatReviewComment(review: GeneratedReview): string {
    const emoji = {
      'critical': 'ðŸ”´',
      'warning': 'ðŸŸ¡', 
      'suggestion': 'ðŸ”µ'
    };

    let body = 'ðŸ¤– **AI Code Review**\n\n';
    
    if (review.comments.length === 0) {
      body += 'âœ… No significant issues found. Code looks good!\n';
      return body;
    }

    // Group comments by severity
    const grouped = {
      critical: review.comments.filter(c => c.severity === 'critical'),
      warning: review.comments.filter(c => c.severity === 'warning'),
      suggestion: review.comments.filter(c => c.severity === 'suggestion'),
    };

    // Add summary
    const counts = {
      critical: grouped.critical.length,
      warning: grouped.warning.length,
      suggestion: grouped.suggestion.length,
    };

    if (counts.critical > 0) {
      body += `ðŸ”´ **${counts.critical} Critical Issue${counts.critical > 1 ? 's' : ''}**\n`;
    }
    if (counts.warning > 0) {
      body += `ðŸŸ¡ **${counts.warning} Warning${counts.warning > 1 ? 's' : ''}**\n`;
    }
    if (counts.suggestion > 0) {
      body += `ðŸ”µ **${counts.suggestion} Suggestion${counts.suggestion > 1 ? 's' : ''}**\n`;
    }

    body += '\n---\n\n';

    // Add detailed comments
    ['critical', 'warning', 'suggestion'].forEach(severity => {
      const comments = grouped[severity as keyof typeof grouped];
      if (comments.length > 0) {
        comments.forEach((comment, index) => {
          body += `${emoji[comment.severity]} **${comment.severity.toUpperCase()}** `;
          body += `(${comment.confidence}% confidence)\n\n`;
          body += `${comment.message.trim()}\n\n`;
        });
      }
    });

    body += '\n---\n*Generated by AI PR Reviewer*';
    return body;
  }
}

export const githubCommentsHandler = new GitHubCommentsHandler();